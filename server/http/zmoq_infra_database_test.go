// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package http_test

import (
	"context"
	"github.com/gharsallahmoez/palindrome/infra/database"
	"github.com/gharsallahmoez/palindrome/model"
	"sync"
)

// Ensure, that DatabaseMock does implement database.Database.
// If this is not the case, regenerate this file with moq.
var _ database.Database = &DatabaseMock{}

// DatabaseMock is a mock implementation of database.Database.
//
//	func TestSomethingThatUsesDatabase(t *testing.T) {
//
//		// make and configure a mocked database.Database
//		mockedDatabase := &DatabaseMock{
//			DeleteMessageFunc: func(id string, ctx context.Context) error {
//				panic("mock out the DeleteMessage method")
//			},
//			GetMessageFunc: func(id string, ctx context.Context) (model.Message, error) {
//				panic("mock out the GetMessage method")
//			},
//			ListMessagesFunc: func(ctx context.Context) ([]model.Message, error) {
//				panic("mock out the ListMessages method")
//			},
//			SaveMessageFunc: func(message model.Message, ctx context.Context) (model.Message, error) {
//				panic("mock out the SaveMessage method")
//			},
//			UpdateMessageFunc: func(id string, content string, isPalindrome bool, ctx context.Context) (model.Message, error) {
//				panic("mock out the UpdateMessage method")
//			},
//		}
//
//		// use mockedDatabase in code that requires database.Database
//		// and then make assertions.
//
//	}
type DatabaseMock struct {
	// DeleteMessageFunc mocks the DeleteMessage method.
	DeleteMessageFunc func(id string, ctx context.Context) error

	// GetMessageFunc mocks the GetMessage method.
	GetMessageFunc func(id string, ctx context.Context) (model.Message, error)

	// ListMessagesFunc mocks the ListMessages method.
	ListMessagesFunc func(ctx context.Context) ([]model.Message, error)

	// SaveMessageFunc mocks the SaveMessage method.
	SaveMessageFunc func(message model.Message, ctx context.Context) (model.Message, error)

	// UpdateMessageFunc mocks the UpdateMessage method.
	UpdateMessageFunc func(id string, content string, isPalindrome bool, ctx context.Context) (model.Message, error)

	// calls tracks calls to the methods.
	calls struct {
		// DeleteMessage holds details about calls to the DeleteMessage method.
		DeleteMessage []struct {
			// ID is the id argument value.
			ID string
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// GetMessage holds details about calls to the GetMessage method.
		GetMessage []struct {
			// ID is the id argument value.
			ID string
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// ListMessages holds details about calls to the ListMessages method.
		ListMessages []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// SaveMessage holds details about calls to the SaveMessage method.
		SaveMessage []struct {
			// Message is the message argument value.
			Message model.Message
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
		// UpdateMessage holds details about calls to the UpdateMessage method.
		UpdateMessage []struct {
			// ID is the id argument value.
			ID string
			// Content is the content argument value.
			Content string
			// IsPalindrome is the isPalindrome argument value.
			IsPalindrome bool
			// Ctx is the ctx argument value.
			Ctx context.Context
		}
	}
	lockDeleteMessage sync.RWMutex
	lockGetMessage    sync.RWMutex
	lockListMessages  sync.RWMutex
	lockSaveMessage   sync.RWMutex
	lockUpdateMessage sync.RWMutex
}

// DeleteMessage calls DeleteMessageFunc.
func (mock *DatabaseMock) DeleteMessage(id string, ctx context.Context) error {
	if mock.DeleteMessageFunc == nil {
		panic("DatabaseMock.DeleteMessageFunc: method is nil but Database.DeleteMessage was just called")
	}
	callInfo := struct {
		ID  string
		Ctx context.Context
	}{
		ID:  id,
		Ctx: ctx,
	}
	mock.lockDeleteMessage.Lock()
	mock.calls.DeleteMessage = append(mock.calls.DeleteMessage, callInfo)
	mock.lockDeleteMessage.Unlock()
	return mock.DeleteMessageFunc(id, ctx)
}

// DeleteMessageCalls gets all the calls that were made to DeleteMessage.
// Check the length with:
//
//	len(mockedDatabase.DeleteMessageCalls())
func (mock *DatabaseMock) DeleteMessageCalls() []struct {
	ID  string
	Ctx context.Context
} {
	var calls []struct {
		ID  string
		Ctx context.Context
	}
	mock.lockDeleteMessage.RLock()
	calls = mock.calls.DeleteMessage
	mock.lockDeleteMessage.RUnlock()
	return calls
}

// GetMessage calls GetMessageFunc.
func (mock *DatabaseMock) GetMessage(id string, ctx context.Context) (model.Message, error) {
	if mock.GetMessageFunc == nil {
		panic("DatabaseMock.GetMessageFunc: method is nil but Database.GetMessage was just called")
	}
	callInfo := struct {
		ID  string
		Ctx context.Context
	}{
		ID:  id,
		Ctx: ctx,
	}
	mock.lockGetMessage.Lock()
	mock.calls.GetMessage = append(mock.calls.GetMessage, callInfo)
	mock.lockGetMessage.Unlock()
	return mock.GetMessageFunc(id, ctx)
}

// GetMessageCalls gets all the calls that were made to GetMessage.
// Check the length with:
//
//	len(mockedDatabase.GetMessageCalls())
func (mock *DatabaseMock) GetMessageCalls() []struct {
	ID  string
	Ctx context.Context
} {
	var calls []struct {
		ID  string
		Ctx context.Context
	}
	mock.lockGetMessage.RLock()
	calls = mock.calls.GetMessage
	mock.lockGetMessage.RUnlock()
	return calls
}

// ListMessages calls ListMessagesFunc.
func (mock *DatabaseMock) ListMessages(ctx context.Context) ([]model.Message, error) {
	if mock.ListMessagesFunc == nil {
		panic("DatabaseMock.ListMessagesFunc: method is nil but Database.ListMessages was just called")
	}
	callInfo := struct {
		Ctx context.Context
	}{
		Ctx: ctx,
	}
	mock.lockListMessages.Lock()
	mock.calls.ListMessages = append(mock.calls.ListMessages, callInfo)
	mock.lockListMessages.Unlock()
	return mock.ListMessagesFunc(ctx)
}

// ListMessagesCalls gets all the calls that were made to ListMessages.
// Check the length with:
//
//	len(mockedDatabase.ListMessagesCalls())
func (mock *DatabaseMock) ListMessagesCalls() []struct {
	Ctx context.Context
} {
	var calls []struct {
		Ctx context.Context
	}
	mock.lockListMessages.RLock()
	calls = mock.calls.ListMessages
	mock.lockListMessages.RUnlock()
	return calls
}

// SaveMessage calls SaveMessageFunc.
func (mock *DatabaseMock) SaveMessage(message model.Message, ctx context.Context) (model.Message, error) {
	if mock.SaveMessageFunc == nil {
		panic("DatabaseMock.SaveMessageFunc: method is nil but Database.SaveMessage was just called")
	}
	callInfo := struct {
		Message model.Message
		Ctx     context.Context
	}{
		Message: message,
		Ctx:     ctx,
	}
	mock.lockSaveMessage.Lock()
	mock.calls.SaveMessage = append(mock.calls.SaveMessage, callInfo)
	mock.lockSaveMessage.Unlock()
	return mock.SaveMessageFunc(message, ctx)
}

// SaveMessageCalls gets all the calls that were made to SaveMessage.
// Check the length with:
//
//	len(mockedDatabase.SaveMessageCalls())
func (mock *DatabaseMock) SaveMessageCalls() []struct {
	Message model.Message
	Ctx     context.Context
} {
	var calls []struct {
		Message model.Message
		Ctx     context.Context
	}
	mock.lockSaveMessage.RLock()
	calls = mock.calls.SaveMessage
	mock.lockSaveMessage.RUnlock()
	return calls
}

// UpdateMessage calls UpdateMessageFunc.
func (mock *DatabaseMock) UpdateMessage(id string, content string, isPalindrome bool, ctx context.Context) (model.Message, error) {
	if mock.UpdateMessageFunc == nil {
		panic("DatabaseMock.UpdateMessageFunc: method is nil but Database.UpdateMessage was just called")
	}
	callInfo := struct {
		ID           string
		Content      string
		IsPalindrome bool
		Ctx          context.Context
	}{
		ID:           id,
		Content:      content,
		IsPalindrome: isPalindrome,
		Ctx:          ctx,
	}
	mock.lockUpdateMessage.Lock()
	mock.calls.UpdateMessage = append(mock.calls.UpdateMessage, callInfo)
	mock.lockUpdateMessage.Unlock()
	return mock.UpdateMessageFunc(id, content, isPalindrome, ctx)
}

// UpdateMessageCalls gets all the calls that were made to UpdateMessage.
// Check the length with:
//
//	len(mockedDatabase.UpdateMessageCalls())
func (mock *DatabaseMock) UpdateMessageCalls() []struct {
	ID           string
	Content      string
	IsPalindrome bool
	Ctx          context.Context
} {
	var calls []struct {
		ID           string
		Content      string
		IsPalindrome bool
		Ctx          context.Context
	}
	mock.lockUpdateMessage.RLock()
	calls = mock.calls.UpdateMessage
	mock.lockUpdateMessage.RUnlock()
	return calls
}
